#Лабораторна робота № 11. Взаємодія з користувачем шляхом механізму
введення/виведення

## 1 ВИМОГИ

### 1.1 Розробник

* Курінна Єлизавета Ігорівна;
* студент групи КН-921г;
* 10-квітня-2022

### 1.2 Загальне завдання

Визначити добуток двох матриць матрицю.


## 2 ОПИС ПРОГРАМИ

### 2.1 Функціональне призначення

Програма призначена для знаходження добутку двох матриць

При генерації  числа діють наступні *обмеження*:

- перемінні rows1, rows2, columns1, columns2  передаються через файл input.txt

Результат зберігається у змінних  *array3*.

Демонстрація знайдених результатів передбачає покрокове виконання програми в режимі налагодження.

### 2.2 Опис логічної структури

Головна функція визиває наступну функцію: `int multy_matrix(int array1, int array2, int array3, int rows1, int rows2, int columns1, int columns2)`;

Під час генерації масиву:

- для отримання псевдовипадкого чисел використовується наступна конструкція  `*(*(array1 + i)+ j = rand()%10`;
*(*(array2 + i)+ j = rand()%10`;

Опис розроблених структур і функцій наводиться на базі результатів роботи системи автодокументування *Doxygen*.

### 2.2.1 Функція визачення суми найбільшого непреривного інтервалу з позитивних чисел
```c

int multy_matrix(int array1, int array2, int array3, int rows1, int rows2, int columns1, int columns2)

```

*Призначення*: визначення добутку двох матриць

*Опис роботи*: функції передається  3 масива і його розмір(рядки і стовпці), де виконуються наступні дії за допомогою циклу for

**Аргументи**: 
-*array1* - масив, який сформований псевдовипадковими числами
-*array2* - масив, який сформований псевдовипадковими числами
-*array2* -  результуючий масив
-*rows1* — рядки першої матриці
-*rows2* — рядки другої матриці
-*columns2* — стовпці другої матриці


###2.2.3 Основна функція

```c

int main()

```
![Поля структури main](assets/1.png)
*Призначення*: головна функція.

*Опис роботи*:

- вводимо перемінні, надаємо їм тип даних;
- виділяємо пам'ять для трьох масивів;
- створення масиву за допомогою генератора псевдовипадкових чисел;
- вивід array3 за допомогою  функції
-звільнення пам'яті;
- повертає функція код повернення з програми (0).


####2.2.4 Структура проекту

```

        └── lab11

            ├── Doxyfile

            ├── Makefile

            ├── README.md

            ├── assets
            │
                  └── input.txt

            ├── doc

            │   └── lab11.md

            ├── src

            │   └── main.c

            │   └── lib.c 

            │   └── lib.h
        



```

### 2.3 Важливі фрагменти програми

#### 2.3.1 Початкові дані. Константи, перерахування

```c

int *array1;
int *array2;
int *array3;
int rows1 = 3;
int columns1 = 2;
int rows2 = 2;
int columns2 = 3;
```

#### 2.3.2 Генерація масиву array1

```c
//виділяємо пам'ять для першого массиву
        int **array1 = (int **)malloc(n * sizeof(int *));
        for (int i = 0; i < n; i++) {
        *(array1 + i) = (int *)malloc(n * sizeof(int));
        }

        //задаємо масив рандомними числами
        for (int i = 0; i < rows1; i++) {
        printf("\n");
        for (int j = 0; j < columns1; j++) {
        *(*(array1 + i) + j) = random() % 10;


```
#### 2.3.3 Генерація масиву array3

```c
//виділяємо пам'ять для першого массиву
        int **array2 = (int **)malloc(n2 * sizeof(int *));
        for (int i = 0; i < n; i++) {
        *(array2 + i) = (int *)malloc(n2 * sizeof(int));
        }

        //задаємо масив рандомними числами
        for (int i = 0; i < rows2; i++) {
        printf("\n");
        for (int j = 0; j < columns2; j++) {
        *(*(array2+ i) + j) = random() % 10;


```
#### 2.3.4 Генерація масиву array3

```c
//виділяємо пам'ять для першого массиву
        int **array3 = (int **)malloc(n3 * sizeof(int *));
        for (int i = 0; i < n; i++) {
        *(array3 + i) = (int *)malloc(n3 * sizeof(int));
        }

        //задаємо масив рандомними числами
        for (int i = 0; i < rows1; i++) {
        printf("\n");
        for (int j = 0; j < columns2; j++) {
        *(*(array3+ i) + j) = random() % 10;


```

## 3 ВАРІАНТИ ВИКОРИСТАННЯ

Для демонстрації результатів кожної задачі використовується:

- покрокове виконання програми в утиліті lldb.

**Варіант використання 1**: послідовність дій для запуску програми у режимі відлагодження:

- запустити програму у відлагоднику lldb;
- поставити точку зупинки на функції main (строка з `return 0;`);
- запустити програму;
- подивитись результати виконання програми, оглядаючи значення змінної *array1* ,*array2*, *array3*, *rows1*, *rows2*, *columns1*. *columns2*

```
(lldb) r
Process 9474 launched: '/home/eliza/programing-kurinna/lab11/dist/main.bin' (x86_64)
Автор: Курінна Єлизавета Ігорівна КН-921г. Лабораторная работа №11.Взаємодія з користувачем шляхов введення/ виведення

3 6 
7 5 
3 5 

6 2 9 
1 2 7 

24 18 69 
47 24 98 
23 16 62 Process 9474 exited with status = 0 (0x00000000) 

```

## ВИСНОВКИ

При виконанні даної лабораторної роботи було набуто практичного досвіду роботи з механізмами виводу/вводу, виділенням і звільненням пам'яті, розробці модульного теста для перевірки коду та його реалізаціїї

