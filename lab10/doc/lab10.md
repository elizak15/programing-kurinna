#Лабораторна робота № 10. Вступ до показчиків

## 1 ВИМОГИ

### 1.1 Розробник

* Курінна Єлизавета Ігорівна;
* студент групи КН-921г;
* 5-квітня-2022

### 1.2 Загальне завдання

Дано масив з N цілих чисел. Знайти безперервну послідовність позитивних чисел у
вхідному масиві, сума елементів якої максимальна, та переписати їх у вихідний масив.




## 2 ОПИС ПРОГРАМИ

### 2.1 Функціональне призначення

Програма призначена для знаходження найбільшого непреривного інтервалу з позитивних чисел. Також програма призначена для передачі цього максимального числа в інший масив

При генерації  числа діють наступні *обмеження*:

- якщо число, яке згенеровано рандомно ділиться на 2, то множимо його на -1, адже нам потрібні для робити як позитивні, так і негативні числа.

Результат зберігається у змінних *maximum_sum* і *array2*.

Демонстрація знайдених результатів передбачає покрокове виконання програми в режимі налагодження.

### 2.2 Опис логічної структури

Головна функція визиває наступну функцію: `int find_maximum(int array1, int n)`;

Під час генерації масиву:

- для отримання псевдовипадкого чисел використовується наступна конструкція  `*(array1 + i) = rand()%10`;


Опис розроблених структур і функцій наводиться на базі результатів роботи системи автодокументування *Doxygen*.

### 2.2.1 Функція визачення суми найбільшого непреривного інтервалу з позитивних чисел
```c

int find_maximum(int array1, int n);

```

*Призначення*: визначення найбільшої суми непреривного інтервалу з позитивних чисел

*Опис роботи*: функції передається масив і його розмір, де виконуються наступні дії за допомогою циклу for, і операндів if та else

**Аргументи**: 
-*array1* - масив, який сформований псевдовипадковими числами
-*n* — розмір масиву


###2.2.3 Основна функція

```c

int main()

```
![Поля структури main](assets/1.png)
*Призначення*: головна функція.

*Опис роботи*:

- вводимо перемінні, надаємо їм тип даних;
- виділяємо пам'ять для двох масивів;
- створення масиву за допомогою генератора псевдовипадкових чисел та для отримання негативного числа, прописання умови(якщо число ділиться на 2, то множимо його на -1);
- вивід в перемінну maximum_sum  найбільшої суми непреривного інтервалу з позитивних чисел `find_maximum`;
- вивід даних перемінної maximum_sum в array2;
-звільнення пам'яті;
- повертає функція код повернення з програми (0).


####2.2.4 Структура проекту

```

        └── lab10

            ├── Doxyfile

            ├── Makefile

            ├── README.md

            ├── doc

            │   └── lab10.md

            ├── src

            │   └── main.c

            │   └── lib.c 

            │   └── lib.h
        



```

### 2.3 Важливі фрагменти програми

#### 2.3.1 Початкові дані. Константи, перерахування

```c

int *array1;
int *array2;
int maximum_sum;
const int n = 5;
const int b = 1;
```

#### 2.3.2 Генерація масиву array1

```c
for (int i = 0; i < n; i++) { // заповняємо масив рандомом, якщо число ділиться на 2, то множимо на -1
*(array1 + i) = random() % 10;
 if (*(array1 + i) % 2 == 0) {
 *(array1 + i) *= -1;
  }
  }


```

## 3 ВАРІАНТИ ВИКОРИСТАННЯ

Для демонстрації результатів кожної задачі використовується:

- покрокове виконання програми в утиліті lldb.

**Варіант використання 1**: послідовність дій для запуску програми у режимі відлагодження:

- запустити програму у відлагоднику lldb;
- поставити точку зупинки на функції main (строка з `return 0;`);
- запустити програму;
- подивитись результати виконання програми, оглядаючи значення змінної *array1* ,*array2*, *maximum_sum*

```
(lldb) p *array1
(int) $0 = 3
(lldb) p *(array1 + 1)
(int) $1 = -6
(lldb) p *(array1 + 2)
(int) $2 = 7
(lldb) p *(array1 + 3)
(int) $3 = 5
(lldb) p *(array1 + 4)
(int) $4 = 3
(lldb) p maximum_sum
(int) $5 = 15
(lldb) p *array2
(int) $6 = 15


```

## ВИСНОВКИ

При виконанні даної лабораторної роботи було набуто практичного досвіду роботи з виділенням і звільненням пам'яті, розробці модульного теста для перевірки коду та його реалізаціїї

